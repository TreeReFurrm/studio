rules_version = '2';

/**
 * @name ReFurrm Scan Marketplace Security Rules
 * @author Your Name
 *
 * @description
 * This ruleset enforces a security model for the ReFurrm Scan marketplace application.
 * It is designed for rapid prototyping, focusing on strict authorization while
 * maintaining flexibility in data schemas.
 *
 * @philosophy Core Philosophy
 * The security model is based on user ownership and role-based access for shared
 * resources like sales. Data is segregated into private user-owned collections
 * and public-readable collections to simplify rules and enhance security.
 *
 * @structure Data Structure
 * - /users/{userId}: Private user profile data, writable only by the owner.
 * - /users/{userId}/items/{itemId}: A private collection of a user's items.
 * - /items/{itemId}: A public, read-only collection of all items for sale, with
 *   writes restricted to the item's owner.
 * - /sales/{saleId}: Transaction records, accessible only by the buyer and seller.
 * - /pickups/{pickupId}, /ethical_contributions/{contributionId}: Sub-resources
 *   related to sales, inheriting access from the parent sale.
 *
 * @decisions Key Security Decisions
 * - User Listing: Listing all users in the `/users` collection is disabled to
 *   protect user privacy.
 * - Ownership: Writes to user-specific data are strictly limited to the data
 *   owner. Publicly-readable documents like items contain a denormalized
 *   `userId` field to enforce ownership for writes.
 * - Shared Access: Access to `sales` and related documents is granted only to
 *   the participating buyer and seller.
 * - Secure by Default: Collections containing sensitive or multi-user data
 *   (like `/sales`) explicitly disable `list` operations, forcing clients to use
 *   secure, targeted queries that are evaluated against per-document read rules.
 *
 * @denormalization Denormalization for Authorization
 * To create simple, performant rules, data required for authorization is
 * denormalized directly onto the documents being secured.
 * - `/items/{itemId}` documents contain a `userId` field, avoiding a lookup to
 *   determine the owner.
 * - `/sales/{saleId}` documents are expected to contain both a `buyerId` and a
 *   `userId` (for the seller), allowing rules to grant access to both parties
 *   without extra reads.
 *
 * @segregation Structural Segregation
 * User items are stored in two locations: a private `/users/{userId}/items`
 * collection for the owner's management, and a separate public `/items`
 * collection for marketplace visibility. This separation allows for distinct
 * security postures for the same logical data, which is more secure and
 * performant than a single collection with a "isPublic" flag.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * @name isSignedIn
     * @description Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @name isOwner
     * @description Checks if the authenticated user's UID matches the given userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @name isExistingDoc
     * @description Checks if a document exists before an update or delete.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * @name isExistingOwner
     * @description Combines ownership and existence checks for update/delete ops.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * @name isSaleParticipant
     * @description Checks if the user is the buyer or seller of a sale.
     * Assumes the sale document has denormalized `buyerId` and `userId` (seller).
     */
    function isSaleParticipant(saleDoc) {
      return isSignedIn() && (request.auth.uid == saleDoc.buyerId || request.auth.uid == saleDoc.userId);
    }
    
    /**
     * @name canReadParentSale
     * @description Secures sub-resources by checking participation in the parent sale.
     * This requires a single `get` call, which is an efficient pattern for securing
     * child documents based on parent permissions.
     */
    function canReadParentSale(saleId) {
      let saleDoc = get(/databases/$(database)/documents/sales/$(saleId)).data;
      return isSaleParticipant(saleDoc);
    }

    /**
     * @name hasValidNewUserData
     * @description Validates the data for a new user document.
     * Enforces that the document's internal `id` matches the document's path ID.
     */
    function hasValidNewUserData(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * @name hasImmutableUserData
     * @description Ensures critical user fields are not changed on update.
     */
    function hasImmutableUserData() {
      return request.resource.data.id == resource.data.id
          && request.resource.data.createdAt == resource.data.createdAt;
    }
    
    /**
     * @name hasValidNewItemData
     * @description Validates a new item, ensuring the owner is the creator.
     */
    function hasValidNewItemData() {
      return request.resource.data.userId == request.auth.uid;
    }
    
    /**
     * @name hasImmutableItemData
     * @description Ensures item ownership cannot be transferred on update.
     */
    function hasImmutableItemData() {
      return request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * @name hasValidNewSaleData
     * @description Validates a new sale, ensuring the creator is the buyer.
     */
    function hasValidNewSaleData() {
      let saleData = request.resource.data;
      return saleData.buyerId == request.auth.uid
          && saleData.buyerId != saleData.userId; // Buyer cannot be the seller
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description User profiles. A user can create their own profile. They can
     *              fully manage their own profile, and other signed-in users can read it.
     * @path /users/{userId}
     * @allow (create) An authenticated user creates their own profile document: /users/USER_123.
     * @deny (create) An authenticated user tries to create a profile for someone else: /users/OTHER_USER.
     * @principle Enforces self-creation and ownership for a user's root document.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false; // Prevent scraping all users
      allow create: if isOwner(userId) && hasValidNewUserData(userId);
      allow update: if isExistingOwner(userId) && hasImmutableUserData();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Private collection of items owned by a user. Only the owner
     *              can perform any action on these documents.
     * @path /users/{userId}/items/{itemId}
     * @allow (read/write) The owner (USER_123) accesses /users/USER_123/items/ITEM_ABC.
     * @deny (read/write) Another user (USER_456) tries to access /users/USER_123/items/ITEM_ABC.
     * @principle Restricts access to a user's own private data tree.
     */
    match /users/{userId}/items/{itemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Public collection of all items available on the marketplace.
     *              Anyone can read this collection, but only the item's owner can create, update, or delete it.
     * @path /items/{itemId}
     * @allow (create) A signed-in user creates an item, setting the `userId` field to their own UID.
     * @deny (update) A user tries to update an item where `resource.data.userId` does not match their UID.
     * @principle Implements public read with owner-only writes, a common pattern for marketplace listings.
     */
    match /items/{itemId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && hasValidNewItemData();
      allow update: if isExistingOwner(resource.data.userId) && hasImmutableItemData();
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Transaction records for sales. Access is restricted to the
     *              buyer and the seller involved in the transaction.
     * @path /sales/{saleId}
     * @allow (get) The buyer or seller of the sale reads the document.
     * @deny (get) A user not involved in the sale tries to read the document.
     * @deny (list) Any user tries to list all sales. This is disabled for security.
     * @principle Implements shared access for a closed set of collaborators (buyer and seller).
     */
    match /sales/{saleId} {
      allow get: if isSaleParticipant(resource.data);
      allow list: if false; // Must query by buyerId or userId, protected by `get` rule
      allow create: if isSignedIn() && hasValidNewSaleData();
      allow update: if false; // Business logic for updates is complex; secure by default.
      allow delete: if false; // Sales records should generally be immutable.
    }

    /**
     * @description Pickup requests for a sold item. Access is granted to the
     *              participants of the parent sale.
     * @path /pickups/{pickupId}
     * @allow (get) The buyer or seller from the parent sale reads the pickup details.
     * @deny (get) A user not involved in the parent sale tries to read the pickup details.
     * @principle Secures a child document by looking up permissions on its parent resource.
     */
    match /pickups/{pickupId} {
      allow get: if canReadParentSale(resource.data.saleId);
      allow list: if false; // Must use targeted queries.
      allow create: if canReadParentSale(request.resource.data.saleId);
      allow update: if false; // Status updates should be handled by backend logic.
      allow delete: if false;
    }
    
    /**
     * @description Ethical funding contributions related to a sale. Access is
     *              granted to the participants of the parent sale.
     * @path /ethical_contributions/{contributionId}
     * @allow (create) The buyer or seller from the parent sale creates a contribution record.
     * @deny (create) A user not involved in the parent sale tries to create a contribution.
     * @principle Secures a child document by looking up permissions on its parent resource.
     */
    match /ethical_contributions/{contributionId} {
      allow get: if canReadParentSale(resource.data.saleId);
      allow list: if false; // Must use targeted queries.
      allow create: if canReadParentSale(request.resource.data.saleId);
      allow update: if false; // Contributions should be immutable.
      allow delete: if false;
    }
  }
}
